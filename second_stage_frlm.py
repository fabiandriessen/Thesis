from pulp import *
import re


def second_stage_frlm(p, c, df_g, df_b, df_eq_fq):
    """ This program optimally sites n charging stations with a max capacity c,
    based on three DataFrames that are generated by the first_stage_FRLM function.
        Parameters
        ----------
        p : int
            #charging stations modules to locate on any node of G.

        c : float
            max (average) flow a charging station can cope with.

        ## the following three inputs are data frames that can be generated using the first_stage_FRLM function
        df_g : pd.DataFrame()
            DataFrame with a row for each route q and a column for each existing charging station combination h.
            b_qh = 1 combination h can support trips on path h, 0 otherwise.

        df_b : pd.DataFrame()
            DataFrame with a row for each charging station combination h, and a column for each unique facility k.
            a_qh = 1 if combination k is in combination h, 0 otherwise.

        df_eq_fq : pd.DataFrame()
            Dataframe with a row for each route q, that contains two columns corresponding f_q and e_q values.
        """

    # define y_qh for each q and each h, and restrict between 0 and 1
    # constraint 1.5 already incorporated
    flow_allocation = pulp.LpVariable.dicts("Flow_captured",
                                         ((q, h) for q, h in df_g.index),
                                         lowBound=0,
                                         upBound=1,
                                         cat='Continuous')

    # amount of facilities to place at each site is also decision var
    facilities_to_build = pulp.LpVariable.dicts("Facilities",
                                     (facility for facility in df_g.columns),
                                     lowBound=0,
                                     cat='Integer')
    # Define problem
    model = LpProblem('CFRLM', LpMaximize)

    # objective function
    model += pulp.lpSum([flow_allocation[q,h] * df_b[h][q] * df_eq_fq['f_q'][q] for q,h in df_g.index])

    # ###############################################constraints##################################################
    # first constraint
    # for each facility
    for key, facility in facilities_to_build.items():
        model += pulp.lpSum(df_eq_fq['e_q'][q] * df_g[key].loc[df_g.index == (q,h)] * df_eq_fq['f_q'][q] *
                           flow_allocation[q,h] for q,h in df_g.index) <= pulp.lpSum(c* facility)

    # second constraint
    model += pulp.lpSum(facilities_to_build[i] for i in facilities_to_build.keys()) <= p

    # third constraint
    for q in df_b.index:
        model += pulp.lpSum([flow_allocation[q,h] * df_b[h][q]] for h in df_g.loc[q].index) <= 1

    print(model)

    # solve
    model.solve()

    status=LpStatus[model.status]
    print(status)
    # Values of decision variables at optimum

    for var in model.variables():
        print('Variable', var, 'is equal to', value(var))

    # Value of objective at optimum
    print('Total supported flow is equal to', value(model.objective))

    # create useful outputs
    output_dict = {}
    optimal_facilities = {}
    optimal_flows = {}

    # all in one dict
    # for var in model.variables():
    #     output_dict[var] = value(var)

    # now divide over dicts ...
    for var in model.variables():
        if 'Facilities' in str(var):
            optimal_facilities[re.sub("[^0-9]", "", str(var))] = value(var)
        else:
            optimal_flows[var] = value(var)

    return optimal_facilities, optimal_flows
